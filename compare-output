#!/usr/bin/python

# For comparing dtalackey output with expected one. Solves the problem of
# variation in output from multi-threaded program.

import sys

if len(sys.argv) != 3:
    print("Usage: compare-output output target")
    print("Allowed target contents:")
    print("line-used-as-is")
    print("optional:line (marks line as optional)")
    print("set (begins a set of lines in arbitrary order, no nested sets)")
    print("subset (like set but all optional and at least one required)")
    print("end (ends a set or subset)")
    print("escape:line (allows line to start with any special word)")
    print("Spaces are ignored before optional:, set, end, escape:")
    sys.exit(5)

# Handles line or lines in arbitrary order. Lines may be optional.
class Target(object):
    def __init__(self):
        self._compulsory = []
        self._optional = []
        self._subset = False
        self._max_optional_len = 0

    def Subset(self):
        self._subset = True

    def Add(self, Target, Optional):
        if Optional or self._subset:
            self._optional.append(Target)
            self._max_optional_len = len(self._optional)
        else:
            self._compulsory.append(Target)

    def __len__(self):
        return len(self._compulsory) + len(self._optional)

    def Check(self, Output):
        for lst in (self._compulsory, self._optional,):
            try:
                del lst[lst.index(Output)]
                return True
            except ValueError:
                pass
        return False

    def Remains(self):
        return len(self._compulsory) > 0 or self._subset and len(self._optional) == self._max_optional_len

# Read target data.
try:
    f = open(sys.argv[2], "r")
except IOError, e:
    print(str(e))
    sys.exit(2)
targets = []
in_set = False
t = Target()
for line in f.readlines():
    optional = False
    s = line.lstrip()
    tgt = None
    if s.startswith("escape:"):
        tgt = s[len("escape:"):]
    elif s.startswith("set"):
        if in_set:
            print("No nested (sub)sets allowed.")
            sys.exit(4)
        in_set = True
    elif s.startswith("subset"):
        if in_set:
            print("No nested (sub)sets allowed.")
            sys.exit(4)
        in_set = True
        t.Subset()
    elif s.startswith("end"):
        if not in_set:
            print("end outside set.")
            sys.exit(4)
        if len(t) == 0:
            print("Empty set not allowed.")
            sys.exit(4)
        in_set = False
    elif s.startswith("optional:"):
        optional = True
        tgt = s[len("optional:"):]
    else:
        tgt = line
    if not tgt is None:
        t.Add(tgt.rstrip("\r\n"), optional)
    if not in_set:
        targets.append(t)
        t = Target()
f.close()
if in_set:
    print("Set remains open.")
    sys.exit(4)

# Read source file line by line.
try:
    f = open(sys.argv[1], "r")
except IOError, e:
    print(str(e))
    sys.exit(3)
idx = 0
line = None
for line in f.readlines():
    if idx == len(targets):
        print("Out of targets.")
        sys.exit(1)
    line = line.rstrip("\r\n")
    while not targets[idx].Check(line):
        if targets[idx].Remains():
            print(line)
            sys.exit(1)
        idx = idx + 1
        if idx == len(targets):
            print("Out of targets.")
            sys.exit(1)
f.close()
if line is None and len(targets) != 0:
    print("No input but targets has items.")
    sys.exit(1)
